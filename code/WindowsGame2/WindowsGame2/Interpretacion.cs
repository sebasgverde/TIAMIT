using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Modelo;
using Controlador;
using FftGuitarTuner;

namespace Vista
{
    ///////////////////////////////////////////////////////////
    //  Generated by Enterprise Architect
    //  Created on:      06-oct-2012 08:58:31 p.m.
    //  Original author: sebastian
    ///////////////////////////////////////////////////////////
    public class Interpretacion : Microsoft.Xna.Framework.Game
    {
        // --------------------for sound capture-----------------
        String isDevice;

        // Declare a buffer array to hold the audio data based on the duration of the recording
        const double recordingSeconds = 0.5;
        byte[] buffer = new byte[Microphone.Default.GetSampleSizeInBytes(TimeSpan.FromSeconds(recordingSeconds))];

        double frequency;
        double closestFrequency;
        string noteName;

        // Tracks the amount of data recorded
        int bytesRead = 0;

        bool isMicrophoneRecording = false;
        int timeSpentRecording = 0;
        bool hasData = false;
        //--------------------------------------------------------
        public GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        public List<Nota> notasVisualizadas;
        List<Texture2D> listaImagenes;

        public int i;
        public GestionarInterpretacionControlador interpCont;

        public Interpretacion(Nota inicial, GestionarInterpretacionControlador inter)
        {
            interpCont = inter;
            notasVisualizadas = new List<Nota>();
            notasVisualizadas.Add(inicial);
            notasVisualizadas[0].posicionX = 700;
            listaImagenes = new List<Texture2D>();
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";

            //--------------capture of the audio
            isDevice = captureAudio();
            if (!isMicrophoneRecording)
            //if (bytesRead < 100000)
            {
                // we are starting to record
                timeSpentRecording = 0;
                Microphone.Default.Start();
            }
            else
            {
                Microphone.Default.Stop();
                hasData = true;
            }
        }

        public String captureAudio()
        {
            Microphone mic = Microphone.Default;
            if (mic == null)
            {
                return "no"; // No microphone is attached to the device
            }
            return "yes";

        }

        /// <summary>
        /// Allows the game to perform any initialization it needs to before starting to run.
        /// This is where it can query for any required services and load any non-graphic
        /// related content.  Calling base.Initialize will enumerate through any components
        /// and initialize them as well.
        /// </summary>
        protected override void Initialize()
        {
            // TODO: Add your initialization logic here

            base.Initialize();
        }


        SpriteFont texto;
        private string frecuen = "";
        public string Frecuen { get { return frecuen; } set { frecuen = value; } }

        public int puntaje;

        // This is a texture we can render.
        Texture2D marcaNotaSig;
        Texture2D marcaNotActual;
        Texture2D fondoPant;

        Texture2D nota1;

        Texture2D whole;
        Texture2D half;
        Texture2D quarter;
        Texture2D eighth;
        Texture2D sixth;

        public int totalNotas;

        double miNumero;
        // Set the coordinates to draw the sprite at.
        Vector2 spritePosition = new Vector2(0, 300);//Vector2.Zero;

        /// <summary>
        /// LoadContent will be called once per game and is the place to load
        /// all of your content.
        /// </summary>
        protected override void LoadContent()
        {
            // Create a new SpriteBatch, which can be used to draw textures.
            whole = Content.Load<Texture2D>("Notas/" + "whole");
            listaImagenes.Add(whole);
            half = Content.Load<Texture2D>("Notas/" + "half");
            listaImagenes.Add(half);
            quarter = Content.Load<Texture2D>("Notas/" + "quarter");
            listaImagenes.Add(quarter);
            eighth = Content.Load<Texture2D>("Notas/" + "eighth");
            listaImagenes.Add(eighth);
            sixth = Content.Load<Texture2D>("Notas/" + "16th");
            listaImagenes.Add(sixth);

            nota1 = listaImagenes[notasVisualizadas[0].indiceImagen];
            spriteBatch = new SpriteBatch(GraphicsDevice);
            marcaNotActual = Content.Load<Texture2D>("redB");
            marcaNotaSig = Content.Load<Texture2D>("redA");



            switch (interpCont.instrument)
            {
                case "diatonicHarmonicaE":
                    fondoPant = Content.Load<Texture2D>("BackgroundGameDiatonicHarmonicaE");
                    break;
                default: //guitar
                    fondoPant = Content.Load<Texture2D>("BackgroundGameGuitar");
                    break;
            }
                
            texto = Content.Load<SpriteFont>("fuente");
            puntaje = 0;
        }

        Nota notaActual;

        int posNotpintarMastil = 0;
        int posNotRevToque;
        int posNotMargen = 0;

        /*public void cambiarNota(Nota notObj, int x)
        {
            nota1 = listaImagenes[notObj.indiceImagen];
            spritePosition.X = x;
            nombreNotaActual = notObj._nombre;
            notaActual = notObj;
        }*/

        public void eliminarNotaSobrepasada()
        {
            //spritePosition.X += notasVisualizadas[0].margenSigNota;
            if (notasVisualizadas.Count > 0)
                notasVisualizadas.RemoveAt(0);
            posNotMargen--;
            posNotpintarMastil--;
        }

        public void cambiarNotaSig(Nota nota)
        {
            posNotMargen++;
            notasVisualizadas.Add(nota);
        }

        public void actualizarSpriPos(int x)
        {
            spritePosition.X = x;
            if (notasVisualizadas.Count > 0)
                notasVisualizadas[0].posicionX = x;
            for (int i = 1; i < notasVisualizadas.Count; i++)
            {
                x += notasVisualizadas[i - 1].margenSigNota;
                notasVisualizadas[i].posicionX = x;
            }

        }

        /// <summary>
        /// UnloadContent will be called once per game and is the place to unload
        /// all content.
        /// </summary>
        protected override void UnloadContent()
        {
            // TODO: Unload any non ContentManager content here
        }


        // ---convert frequency detected in note-----------
        string[] NoteNames = { "A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#" };
        double ToneStep = Math.Pow(2, 1.0 / 12);

        void frequency2Note(double frequency, out double closestFrequency, out string noteName)
        {
            const double AFrequency = 440.0;
            const int ToneIndexOffsetToPositives = 120;

            int toneIndex = (int)Math.Round(Math.Log(frequency / AFrequency, ToneStep));
            noteName = NoteNames[(ToneIndexOffsetToPositives + toneIndex) % NoteNames.Length];
            closestFrequency = Math.Pow(ToneStep, toneIndex) * AFrequency;
        }
        //-----------------------------------------------

        public event handlerZonasCriticas pausar;
        /// <summary>
        /// Allows the game to run logic such as updating the world,
        /// checking for collisions, gathering input, and playing audio.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Update(GameTime gameTime)
        {
            // Allows the game to exit
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == Microsoft.Xna.Framework.Input.ButtonState.Pressed)
                this.Exit();
            if (Keyboard.GetState().IsKeyDown(Keys.P))
                pausar();

            if (bytesRead < buffer.Length)
            {

                // public int GetData (byte[] buffer,int offset,int count)
                // this method is really bad explained in msdn I almost had to do reverse engineering, 
                // it basically takes the whole recording 
                // and put the data in the buffer array starting in position offset and getting also the data from postion
                // offset, and maximal until position count, this way it fills gradualy the buffer array
                bytesRead += Microphone.Default.GetData(buffer, bytesRead, (buffer.Length - bytesRead));

                // in this case it just put in the buffer the last data obtained since last getdata called,
                // put it in buffer starting in pos 0, so you have to know the size of new data doing the difference
                // to know until where is the new data, this could be very useful, but I decided to use
                // samples of half second and then restart the buffer so is not necessary
                //
                //int old = bytesRead;
                //bytesRead += Microphone.Default.GetData(buffer);
                //dif = bytesRead - old; //dif-1 is the pos of last current element in buffer
            }
            else
            {
                isMicrophoneRecording = true;
                //short[] ensayo = (short[])buffer;

                double MinFreq = 60;
                double MaxFreq = 1300;
                int SampleRate = 44100;

                // Scaling the samples to send to external method
                double[] scaledBuffer = new double[buffer.Length];
                for (int i = 0; i < scaledBuffer.Length; i++)
                {
                    // 255 is maximal number in byte type
                    scaledBuffer[i] = buffer[i] / 255.0;
                }

                // external method to find frequency
                // this can be replaced for any method with next description:
                // it must receive an array of scaleted samples of wav file and return the frequency
                frequency = FrequencyUtils.FindFundamentalFrequency(scaledBuffer, SampleRate, MinFreq, MaxFreq);

                if (frequency > 0)
                {
                    frequency2Note(frequency, out closestFrequency, out noteName);
                    Console.WriteLine(frequency.ToString("f2") + " " + closestFrequency.ToString("f2") + " " + noteName);
                    interpCont.verificarNotaDetectada(noteName);
                }


                bytesRead = 0;
                isMicrophoneRecording = false;
            }

            // TODO: Add your update logic here
            UpdateSprite(gameTime);

            //base.Update(gameTime);
        }

        public delegate void handlerZonasCriticas();
        public event handlerZonasCriticas sobrepasarPantalla;
        public event handlerZonasCriticas sobrepasarMargenSig;
        public event handlerZonasCriticas terminarJuego;

        public void comprobar()
        {
            int MaxX =
                graphics.GraphicsDevice.Viewport.Width - fondoPant.Width;
            int MinX = 0;

            // Check for bounce.
            try
            {
                if (notasVisualizadas.Count == 0)
                    terminarJuego();
                if (spritePosition.X < MinX)
                {
                    //sobrepasarPantalla();
                    //i += 1;
                    //spritePosition.X = 700;
                    //interpCont.interp_sobrepasarPantalla();
                    sobrepasarPantalla();
                }
                if (posNotMargen < notasVisualizadas.Count && posNotMargen >= 0)
                {
                    if (notasVisualizadas[posNotMargen].posicionX < graphics.GraphicsDevice.Viewport.Width - notasVisualizadas[posNotMargen].margenSigNota)
                    {
                        sobrepasarMargenSig();
                    }
                }
                if (posNotpintarMastil < notasVisualizadas.Count)
                {
                    if (notasVisualizadas[posNotpintarMastil].posicionX < 211)
                        posNotpintarMastil++;
                }
            }
            catch (Exception e)
            { }
            //return position;
        }

        void UpdateSprite(GameTime gameTime)
        {

            //comprobar();
        }



        /// <summary>
        /// This is called when the game should draw itself.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>

        protected override void Draw(GameTime gameTime)
        {
            graphics.GraphicsDevice.Clear(Color.Black);
            Vector2 asd = new Vector2(0, 0);
            Vector2 asd2 = new Vector2(9, 450);
            // Draw the sprite.
            spriteBatch.Begin(SpriteSortMode.BackToFront, BlendState.AlphaBlend);
            spriteBatch.Draw(fondoPant, asd, Color.White);
            spriteBatch.End();

            spriteBatch.Begin(SpriteSortMode.BackToFront, BlendState.AlphaBlend);

            spriteBatch.Draw(nota1, spritePosition, Color.White);
            if (posNotpintarMastil < notasVisualizadas.Count)
            {
                for (int i = 0; i < notasVisualizadas[posNotpintarMastil].posicionMastilX.Count; i++)
                {
                    Vector2 temp = new Vector2(notasVisualizadas[posNotpintarMastil].posicionMastilX[i], notasVisualizadas[posNotpintarMastil].posicionMastilY[i]);
                    spriteBatch.Draw(marcaNotActual, temp, Color.White);
                }
            }
            /*if (posNotpintarMastil+1 < notasVisualizadas.Count)
            {
                for (int i = 0; i < notasVisualizadas[posNotpintarMastil+1].posicionMastilX.Count; i++)
                {
                    Vector2 temp = new Vector2(notasVisualizadas[posNotpintarMastil+1].posicionMastilX[i], notasVisualizadas[posNotpintarMastil+1].posicionMastilY[i]);
                    spriteBatch.Draw(marcaNotaSig, temp, Color.White);
                }
            }*/
            if (notasVisualizadas.Count > 0)
            {
                spriteBatch.DrawString(texto, "nota objetivo: " + notasVisualizadas[0]._nombre, asd2, Color.Black);
                spritePosition.Y = notasVisualizadas[0]._posicionPart;
            }
            for (int i = 1; i < notasVisualizadas.Count; i++)
            {
                Texture2D temp = listaImagenes[notasVisualizadas[i].indiceImagen];
                //float tempX = spritePosition.X + notasVisualizadas[i].margenSigNota;
                float tempX = notasVisualizadas[i].posicionX;
                float tempY = notasVisualizadas[i]._posicionPart ;
                Vector2 vecTemp = new Vector2(tempX, tempY);
                spriteBatch.Draw(temp, vecTemp, Color.White);

                if (notasVisualizadas[i]._nombre.Contains("#"))
                {
                    vecTemp = new Vector2(tempX+15, tempY);
                    spriteBatch.DrawString(texto, "#", vecTemp, Color.Black);
                }
                    

            }
            //sobrepasarPantalla();
            /*spriteBatch.DrawString(texto, notasVisualizadas[0]._nombre/* + " " + Convert.ToString(posNotMargen) + " " + notasVisualizadas[posNotpintarMastil].posicionX
                     + " " + (graphics.GraphicsDevice.Viewport.Width - notasVisualizadas[posNotMargen].margenSigNota) + " " + frecuen, asd * 5, Color.Black);
             */
            asd2.X = 560;
            spriteBatch.DrawString(texto, puntaje + "/"+totalNotas, asd2, Color.Black);

            spriteBatch.End();

            base.Draw(gameTime);

        }
    }
}
